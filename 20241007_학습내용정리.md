## 암호화와 복호화 (Encryption and Decryption)

암호화는 데이터를 외부로부터 보호하기 위해 평문 데이터를 암호로 변환하는 과정이다. 반대로, 복호화는 암호화된 데이터를 다시 원래의 평문으로 되돌리는 과정이다.

#### 암호화 종류
1. **복호화가 가능한 암호화**:
   복호화가 가능한 암호화는 데이터를 암호화한 후 다시 평문으로 복원할 수 있는 방식이다. 이메일, 주소, 계좌번호, 카드번호와 같은 정보는 나중에 다시 사용해야 하기 때문에 복호화가 가능한 암호화 방식을 사용한다.
   예를 들어, 개인 식별 정보(PII)나 금융 정보 등은 시스템에서 다시 읽어야 하기 때문에 복호화 가능한 알고리즘을 사용해 데이터를 보호하면서 필요할 때 원래 값으로 복원할 수 있어야 한다.

2. **복호화가 불가능한 암호화**:
   복호화가 불가능한 암호화는 암호화 후 절대 복호화할 수 없는 방식이다. 이 방식은 비밀번호와 같은 데이터에 적합하다. 비밀번호는 복호화할 수 없게 하면, 해커가 데이터베이스에 접근하더라도 원래 비밀번호를 알 수 없어 보안성이 강화된다.

## 비밀번호 보안 (Password Security)

#### SHA 알고리즘 + Salt
비밀번호를 안전하게 저장하는 가장 흔한 방법은 SHA(Secure Hash Algorithm)와 Salt를 결합하는 방식이다. 이 방식은 비밀번호를 해시값으로 변환하고, Salt라는 추가 데이터를 이용해 각 사용자의 비밀번호가 다르게 저장된다.
  
1. **SHA (Secure Hash Algorithm)**:
   SHA는 데이터를 일정한 길이의 해시값으로 변환하는 해시 함수다. 생성된 해시값은 원래 데이터를 복호화할 수 없다. SHA-256은 256비트 길이의 해시값을 생성하는 알고리즘으로, 현재 업계에서 가장 널리 사용된다. SHA 알고리즘은 비밀번호를 해시화하여 저장하고, 원래 비밀번호로 다시 복호화할 수 없게 만들어준다.

2. **Salt (간 추가)**:
   Salt는 각 사용자별로 고유한 무작위 문자열을 생성해 비밀번호와 결합하여 해시를 생성하는 방식이다. 이 과정은 동일한 비밀번호를 가진 사용자라도 서로 다른 해시값을 갖게 만들어 해킹을 더 어렵게 만들어준다. Salt는 물리적으로 분리된 데이터베이스에 저장하여 보안을 강화해야 한다. Salt는 비밀번호 해시값과 함께 저장되지만, 공격자가 Salt에 접근하기 어렵게 함으로써 데이터 보호를 더욱 철저히 할 수 있다.

3. **복호화 방지**:
   SHA 알고리즘과 Salt를 결합한 비밀번호 암호화 방식은 복호화를 원천적으로 방지한다. 이 방식은 비밀번호를 원래대로 되돌릴 수 없기 때문에 보안성이 높아진다. 비밀번호는 복호화가 절대 불가능해야 한다는 것이 보안의 중요한 원칙이다. 한 번 해시된 비밀번호는 사용자가 다시 입력하는 비밀번호와 비교할 때만 검증되며, 복호화할 필요가 없다.

## 개인정보 보호 (Personal Information Protection)

개인정보란 개인을 식별할 수 있는 모든 정보를 의미한다. 개인정보는 반드시 암호화해야 하고, 법적으로도 암호화가 요구된다. 개인정보를 암호화하지 않으면 해킹, 정보 유출 등 다양한 보안 위험에 노출될 수 있다.

### 개인정보 암호화의 필요성
- **개인정보의 정의**: 개인정보란 이름, 전화번호, 이메일 주소 등 개인을 특정할 수 있는 정보를 의미한다. 이러한 정보는 직접적으로 개인을 식별할 수 있기 때문에 보호가 필요하다.
- **암호화해야 하는 데이터**: 개인정보 중에서 이메일, 이름, 주소, 전화번호, 계좌번호, 카드번호 등은 암호화가 필수적이다. 이 데이터들은 주로 복호화가 가능한 방식으로 암호화해야 한다. 다시 사용해야 할 필요가 있기 때문이다.
- **민감 정보와 암호화 방식**:
  - **복호화가 필요한 정보**: 이메일, 주소, 계좌번호는 나중에 다시 사용해야 하므로 복호화가 가능한 암호화 방식을 사용해야 한다.
  - **복호화가 불가능한 정보**: 비밀번호와 같은 정보는 복호화가 불가능해야 한다. 이 데이터는 복호화할 필요가 없기 때문에 해시 알고리즘을 통해 암호화하고, 다시 복구할 수 없는 방식으로 저장해야 한다.

## 암호화 알고리즘
1. **SHA-256**: 비밀번호와 같이 복호화할 필요가 없는 정보를 암호화할 때 사용되는 가장 흔한 알고리즘이다. SHA-256은 안전하고, 해킹이 어렵기 때문에 많은 시스템에서 비밀번호 암호화에 사용된다.
   
2. **MD5**: 예전에는 많이 사용되었지만, 이제는 보안상 안전하지 않기 때문에 실무에서는 거의 사용되지 않는다. MD5는 해시 충돌과 취약점이 많아 공격자가 데이터를 복호화하거나 조작하기 쉬워졌다.

## Spring Framework 관련 개념

### ComponentScan
ComponentScan은 스프링이 실행될 때, 특정 패키지를 자동으로 스캔하여 `@Component`, `@Service`, `@Repository`, `@Controller` 어노테이션이 붙어 있는 클래스를 찾아 빈(bean)으로 등록하는 과정이다. 이 과정을 통해 스프링 컨테이너에서 의존성 주입(Dependency Injection)을 자동으로 처리하고 각 컴포넌트를 관리하게 된다.

### @Bean
@Bean은 스프링에서 수동으로 빈을 등록하는 방식이다. 메소드에 @Bean 어노테이션을 붙이면, 해당 메소드는 실행될 때 반환되는 객체를 스프링 빈으로 등록한다. 하지만 @Bean으로 등록된 객체는 자동으로 주입되지 않기 때문에 수동으로 인젝션을 처리해야 한다.

### 자동 인젝션
자동 인젝션은 `@Component`, `@Service`, `@Repository`, `@Controller` 등의 어노테이션을 통해 스프링이 의존성을 자동으로 주입하는 방식이다. `@Autowired`를 통해 자동으로 빈을 주입받을 수 있다. 반면, 수동 인젝션은 @Bean으로 직접 생성한 객체에 의존성을 수동으로 주입하는 방식이다.

## Validation과 VO (Value Object)

### VO(Value Object) 분리
VO는 값 객체로, 데이터를 담는 객체다. VO를 분리하여 관리하면 유지보수가 훨씬 용이하다. 각 VO는 각각의 역할에 맞게 나누어 관리할 수 있기 때문에 코드의 복잡도를 낮추고, 데이터 흐름을 더 명확하게 파악할 수 있다. 예를 들어, 회원 가입 정보, 로그인 정보, 계정 정보 등을 각각의 VO로 분리하면 특정 기능에 필요한 데이터만 포함시킬 수 있다. 이렇게 하면 유지보수가 훨씬 수월해진다.

### Validation의 한계
스프링에서는 기본적으로 제공하는 Validation 기능을 이용해 간단한 값 검증을 할 수 있다. 예를 들어, 이메일 형식이나 필수 값 입력 여부를 검사할 수 있다. 하지만 복잡한 조건이나 디테일한 검증이 필요할 때는 기본 Validation만으로 충분하지 않다. 이런 경우 추가적인 검증 로직을 직접 작성하거나 커스텀 Validation을 구현해야 한다.

## 예외 처리 (Exception Handling)

### 일괄 예외 처리 컨트롤러
스프링에서는 `@ControllerAdvice` 어노테이션을 사용하여 전역적으로 발생하는 예외를 일괄적으로 처리하는 컨트롤러를 만들 수 있다. 이를 통해 다양한 예외 상황에 대해 한 곳에서 처리할 수 있고, 개별 컨트롤러마다 예외 처리 로직을 작성하지 않아도 된다. 예를 들어, API 요청 처리 중 데이터베이스 연결 실패나 입력값 검증 실패 같은 공통적인 예외를 전역에서 처리할 수 있다.

### 일괄 처리의 장점
일괄 예외 처리를 통해 모든 예외를 통합적으로 관리할 수 있다. 새로운 예외가 추가되거나 처리 방식이 변경될 경우 한 곳에서 수정하면 되기 때문에 유지보수가 간편해진다. 또한, 개별 컨트롤러에 예외 처리 로직을 중복 작성할 필요가 없어 코드의 가독성이 향상된다.

### 결론 (Summary)

1. **암호화**는 데이터 보호를 위해 필수이며, 특히 비밀번호는 SHA-256과 Salt를 사용해 복호화가 불가능하게 저장해야 한다.
2. **개인정보 보호**를 위해 이메일, 전화번호, 주소 등 개인을 식별할 수 있는 정보는 암호화가 필요하며, 법적으로도 이를 암호화해야 한다.
3. **스프링 구조**에서 ComponentScan은 자동으로 빈을 스캔하여 관리하며, @Bean을 사용한 빈은 수동 인젝션이 필요하다.
4. **Validation**은 VO 분리를 통해 더 효율적으로 관리할 수 있고, 복잡한 검증 로직이 필요할 때는 추가적인 로직을 구현해야 한다.
5. **예외 처리**는 일괄 예외 처리 컨트롤러를 사용하면 모든 예외를 통합적으로 관리할 수 있어 일관된 예외 처리가 가능하다.

